Kubernetes is a container orchestration platform,
It automates deployment, scaling and management of containerized applications.
It abstracts the underlying infrastructure, 
handles load balancing, service discovery, self healing
and enables rolling updates with minimal downtime.

A Pod is the smallest unit in Kubernetes. 
It can contain one or more containers in it. 
They share the same network namespace, 
so they can communicate with each other without a additional networking configuration.

Nodes
Node is a worker machine that runs your applications, 
which can be a virtual machine in the cloud or a physical server. 
Each Node runs Pods, 
and includes components like the 
kubelet             to communicate with the Kubernetes control plane, 
container runtime   like Docker to run containers
Kubeproxy
Nodes are crucial for scaling and managing workloads. 

Kubernetes services expose pods internally or externally, 
offering stable endpoints, service discovery, and load balancing across pods. 
They ensure your pods can communicate efficiently.
ClusterIp, NodePort and LoadBalancer

Let's talk about ConfigMaps and Secrets! 
They store configuration data and sensitive information separately from the pods, 
allowing you to keep your application configuration flexible and manageable.

Deployments handle scaling, updates, and rollback for pods; 
They support rolling updates to ensure minimal downtime, 
and can roll back to previous versions if issues arise. 
Deployments also help in maintaining a consistent state during node failures and provide a record of changes for auditing. 

A Deployment in Kubernetes manages the lifecycle of pods. 
It ensures 
    the number of replicas, 
    container image version, and 
    update strategy is consistently maintained across the cluster.
2. Replica Management:  Automatically creates and maintains the specified number of pod replicas.
3. Rolling Updates:     Updates pods incrementally, replacing old pods with new ones gradually.
4. Rollback Capability: If something goes wrong, you can revert to a previous stable version.
5. Self-Healing:        If a pod crashes or a node fails, the Deployment controller replaces it automatically.
6. Version Control: Each update creates a new ReplicaSet, allowing you to track revisions.
7. Pause/Resume Rollouts: You can pause a rollout to apply multiple changes, then resume when ready.
8. Label-Based Selection: Uses selectors to manage which pods belong to the Deployment.
9. Integration with Services: Works seamlessly with Kubernetes Services to expose your application.
10. Scalability: Easily scale up or down by changing the replica countâ€”manually or via autoscalers.

